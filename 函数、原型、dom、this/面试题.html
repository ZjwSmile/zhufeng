<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script>
    Function.prototype.myCall=function(context){

        //让this这个函数中的this关键字变为context
//      2 让fn方法执行
        this();

    }
    function fn1(){
        console.log(1);
    }
    function fn2(){
        console.log(2);
    }
   // fn1.call(fn2);//首先fn1通过原型链机制找到Function.prototype上的call方法，并且让call方法执行--此时call方法中的this就是我要操作的
    // fn1，在call方法中执行的过程中首先让fn1中的this变成fn2，然后fn1执行

   // fn1.call.call(fn2);//首先fn1通过原型链机制找到Function.prototype上的call方法,然后再让call方法通过原型再找到Function.prototype上的call
    // 方法（因为call本身的值也是一个函数，所以同样可以找到Function.prototype），在第二次找到call的时候，让方法执行，方法中的this是fn1.call,首页让
    // 这个放在中的this变为fn2，然后再让fn1.call执行     2
/*    function  aaa(context){

        //让this这个函数中的this关键字变为context
//      2 让fn方法执行
        this();//变为fn2();

    }

    Function.prototype.myCall=aaa;*/

 //   fn1.call.call(fn2);
    //fn1.call   --aaa
    //aaa.call(fn2)  先让call方法执行，call中的this是aaa，让aaa中的this变为fn2，然后让aaa执行

    Function.prototype.call(fn2); //

    Function.prototype.call.call.call.call.call(fn2);
</script>