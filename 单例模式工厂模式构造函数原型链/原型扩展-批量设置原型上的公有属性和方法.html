<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script>
    //1.起一个别名
/*    function Fn(){
        this.x=100;
    }
    var pro=Fn.prototype;//把原来原型指向的四肢赋值给我们的pro，现在它们操作的是同一个内存空间


    pro.getX=function(){

    }
    pro.getY=function(){

    }
    pro.getZ=function(){

    }
    var f1=new Fn;*/

//    2.重构原型对象的方式--自己先开辟一个堆内存，存储我们公有的属性和方法，把浏览器原来个Fn.prototype开辟的那个替换掉
/*    function Fn(){
        this.x=100;
    }
Fn.prototype={
    constructor:Fn,//手动增加constructor指向
    a:function(){

    },
    b:function(){

    }
}
    var f=new Fn;
//  1.  只有浏览器天生给Fn.prototype开辟的堆内存里面才有constructor，而我们自己开辟的这个堆内存没有这个属性，这样constructor指向就不在是Fn，而是OBJECT了

    console.log(f.constructor);//没做任何处理之前--Object  手动增加之后Fn*/
//    为了和原来的保持一致，我们需要手动的增加constructor指向

//    2.用这种方式给内置类增加公有的属性
    //给内置类Array增加数组去重的方法
/*    Array.prototype.unique=function(){

    }*/
/*    Array.prototype={
        constructor:Array,
        unique:function(){

        }
    }
    console.log(Array.prototype);*/
//    我们这种方式会把之前已经存在于原型上的方法和属性给替换掉了，所以我们用这种方式修改内置类的话，浏览器是给屏蔽掉的
//    但是我们可以一个个的修改内置的方法，当我们通过下述方式在数组的原型上增加方法，如果方法名和原来内置的重复了，会把人家内置的修改掉--我们
// 以后在内置类的原型上增加方法，命名都需要增加特殊的前缀
    Array.prototype.sort=function(){
        console.log(this);//this->ary我们当前要操作的这个数组
    }

    var ary=[1,2,3,1,3,4];
    ary.sort();
    console.log(ary)


</script>