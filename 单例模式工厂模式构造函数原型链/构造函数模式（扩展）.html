<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script>
/*    function Fn(){
        this.x=100;
        this.getX=function(){
//            this->需要看getX执行的时候才知道
            console.log(this.x)
        }
    }
    var f1=new Fn();
    f1.getX();//方法中的this是f1--100

    var ss=f1.getX;
    ss();//方法中的this是window--undefined*/

    //1在构造函数模式中 new Fn执行，如果Fn中不需要传递参数的话，后面的小括号可以省略
//    2 this的问题：在类中出现的this.xxx=xxx中的this都是当前类的实例，而某一个属性值（方法），方法中的this需要看方法执行的时候，前面是否有“.”，才能知道this是谁


/*function Fn(){
    var num=10;
    this.x=100;
    this.getX=function(){
//            this->需要看getX执行的时候才知道
        console.log(this.x)
    }
}
var f1=new Fn;
console.log(f1.num);//undefined*/
//    3
//    类有普通函数的一面，当函数执行的时候，var的num其实只是当前形成的私有作用域中的私有变量而已，它和f1这个实例没有任何关系；只有this.xxx=xxx才相当于给f1这个实例增加私有的属性和方法，才和我们的f1有关系

/*function Fn(){
    this.x=100;
    this.getX=function(){
//            this->需要看getX执行的时候才知道
        console.log(this.x)
    }
    return {name:"ssdffds"}
}
var f1=new Fn;
    console.log(f1);*/
//4  在构造函数模式中，浏览器会默认的把我们的实例返回，返回的是一个对象数据类型的值
//    ，如果我们自己手动写了return返回：
//    若返回的是一个基本数据类型的值，当前实例是不变的，例如return 100;,我们的f1还是当前fn类的实例
//    若返回的是一个引用数据类型的值，当前的实例会被自己返回的值给替换掉，例如 return {name:"sdfsd"} 我们的f1就不在是fn的实例了，而是对象{name:"sdfsd"}


/*function Fn(){
    this.x=100;
    this.getX=function(){
//            this->需要看getX执行的时候才知道
        console.log(this.x)
    }
}
var f1=new Fn;*/
//    5 检测某一个实例是否属于这个类---instanceof

  /*  console.log(f1 instanceof Fn);//true
console.log(f1 instanceof Array); //false
console.log(f1 instanceof Object);//true  因为所以的实例都是对象数据类型的，而每一个对象数据类型都是Object这个内置类的一个实例，所以f1也是他的一个实例
    */

//    对于检测数据类型来说：typeof有自己的局限性，不能细分object下的对象、数组和正则。。。
/*    var a=[];
    console.log(a instanceof  Array)//TRue*说明a是一个数组

    */

 function Fn(){
 this.x=100;
 this.getX=function(){
 //            this->需要看getX执行的时候才知道
 console.log(this.x)
 }
 }
 var f1=new Fn;
    var f2=new Fn;
//    6,f1和f2都是Fn这个类的一个实例，都拥有x和getX两个属性，但是这两个属性是各自的私有的属性，所以：
    //console.log(f1.getX===f2.getX);//false

//    in:检测某一个属性是否属于这个对象 attr in object,不管是私有的属性还是共有的属性，只有存在，用in来检测都是true
    //console.log("getX" in f1);//true
//hasOwnProperty:用来检测某一个属性是否为这个对象的“私有属性”，这个方法只能检测私有的属性
//console.log(f1.hasOwnProperty("getX"))//true;

//    思考，检测某一个属性是否为该对象的共有属性 hasPubProperty

    function hsaPubProperty(obj,attr){
//        首先保证是他的一个属性 并且不是私有属性 则只能是共有属性
        return attr in obj && !obj.hasOwnProperty(attr);
    }

console.log(hsaPubProperty(f1,"getX"))//false

//    7 isPrototypeof





</script>