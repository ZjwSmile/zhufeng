<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script>
    "usr strict";//告诉当前浏览器接下来的js代码将按照严格模式进行编写
    var obj={
        name:"珠峰"
    }
    function fn(num1,num2){
      //  console.log(num1+num2)
        console.log(this)
    }
 //   fn(100,200);//this--window num1=100 num2=200
    //fn.call(100,200);//this--100 num1=200,num2=undefined
    fn.call(obj,100,200);  //this--obj num1=100 num2=200
    fn.call();//this--window     在严格模式下this--undefined
    fn.call(null)//this--window  在严格模式下this--null
    fn.call(undefined)//this--window  严格模式下this--undefined


//    apply和call的作用一模一样的，都是用来改变方法的this关键字，并且把方法
// 执行，并且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规律也是一样的

    fn.call(obj,100,200);//改变this和执行fn函数一起完成了
    fn.apply(obj,[100,200])//call在给fn传递参数时是一个个传递的，而apply不是一个个传，而是要把fn传递的参数值统一的放在一个数组中进行
    // 操作，但是也相当于一个个的给fn的形参赋值


//    bind:这个方法在IE6-8下不兼容,和call、apply类似都用来改变this关键字
//预处理：事先把fn的this改变为我们想要的结果，并且把对应的参数值也准备好了，以后用到了，直接执行
    var tempFn=fn.bind(obj,1,2);//只是改变了fn中的this为obj，并且给fn传递了两个参数值1和2，但是此时并没有把fn这个函数
    // 执行，执行bind会有一个返回值，这个返回值tempFn就是我们把fn的this改变后的那个结果

    tempFn();



</script>